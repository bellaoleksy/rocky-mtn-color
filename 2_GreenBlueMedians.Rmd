---
title: "2009-2020 lake colors and controls"
author: "Matthew Ross"
date: "01/12/2022"
output: html_document
editor_options: 
  chunk_output_type: console
---






```{r setup, include=FALSE}
library(tidyverse)
library(leaflet)
library(sf)
library(feather)
library(lubridate)
library(mapview)
library(USAboundaries)
library(s2)
library(elevatr)
library(trend)
library(tsibble)
library(imputeTS)
library(ggthemes)
library(nhdplusTools)
library(tmap)
library(raster)
library(caret)
library(rpart)
library(yardstick)
library(rpart.plot)
library(here)
library(data.table)
library(cvms)
library(skimr)
library(huxtable)

# Use dplyr select
select<-dplyr::select

sf_use_s2(use_s2 = T)
knitr::opts_chunk$set(echo = TRUE, warning = F, comment = F, message = F)

```


# Where blue green lakes are

## Pull in data
```{r}
load("data/glcp_sub.RData")
load("data/color_summary.RData")
load("data/lake_descriptor.RData")
load("data/ls_elev.RData")
# load("data/nhd_lakes.RData")


```


### Super join to all things w/ Median DWL 2009-2020

```{r}

#Grab modern decade median color
co_summary_median <- ls_co %>%
  dplyr::select(-year, -sat) %>%
  mutate(month = month(date),
         year = year(date),
         doy = yday(date)) %>%
  filter(month %in% 7:9, 
         doy <= 258, #Sept 14/15
         year >= 2009,
         elevation > 1400) %>% 
  group_by(Hylak_id) %>%
  add_count() %>%
  filter(n >= 30) %>%
  group_by(Hylak_id) %>%
  summarize(across(c(Blue:dWL),
                   .fns = list(mean = mean, 
                               sd = sd, 
                               max = max,
                               min = min,
                               median = median), na.rm = T,
                   .names = "{.col}-{.fn}"))%>% 
  ungroup() %>%
  pivot_longer(cols = `Blue-mean`:`dWL-median`,
               names_to = c('var','stat'),
               names_sep = '-')

#Grab just median dWL for each lake
dwl_medians <- co_summary_median %>%
  filter(var == 'dWL',
         stat == 'median') %>%
  select(-var,-stat) %>%
  rename(dWL = value)


#From recent decade to match map
blue_green_2018 <- glcp_high_lakes %>%
  filter(year >= 2009) %>%
  inner_join(dwl_medians) %>%
  group_by(Hylak_id) %>%
  summarize(across(where(is.numeric),median, na.rm = T)) %>%
  mutate(group = cut(dWL, 
                     breaks = c(0,530,Inf), 
                     labels = c('Blue/clear',
                                          'Green/murky'))) %>%
  dplyr::filter(!is.na(dWL)) %>%
  inner_join(lake_descriptor) %>%
  mutate(air_temp = mean_annual_temp_k - 273.15,
         PctUrb2016Ws = PctUrbLo2016Ws + PctUrbMd2016Ws + PctUrbHi2016Ws,
         PctWet2016Ws = PctWdWet2016Ws + PctHbWet2016Ws) %>%
  # LakeCAT and GLCP predictors, maybe add in land use when fixed
  dplyr::select(precip = mean_monthly_precip_mm,
                air_temp,
                res = lake_rsvr_class,
                lake_connectivity = lake_connectivity_class,
                area = areasqkm, # different from ws_area below???
                elev = elevation,
                meandepth,
                pop_sum,
                maxdepth,
                ws_area = WsAreaSqKm,
                no3_dep = NO3_2018Ws,
                nh3_dep = NH4_2018Ws,
                carb = PctCarbResidWs,
                sil = PctSilicicWs, 
                LSA = lake_waterarea_ha, #lake surface area [ha]
                # perc_open_water = PctOw2016Ws, #% open water 2016
                perc_ice = PctIce2016Ws,#% of catchment area classified as ice/snow land cover
                perc_urban = PctUrb2016Ws, #% of catchment area classified as developed, low+med+high-intensity land use
                perc_decid = PctDecid2016Ws, #% of catchment area classified as deciduous forest land cover
                perc_conifer = PctConif2016Ws, #% of catchment area classified as evergreen forest land cover 
                perc_mixedForest = PctMxFst2016Ws,#% of catchment area classified as mixed deciduous/evergreen forest land cover
                perc_shrub = PctShrb2016Ws, #% of catchment area classified as shrub/scrub land cover 
                perc_grass = PctGrs2016Ws, #% of watershed area classified as grassland/herbaceous land cover 
                perc_hay = PctHay2016Ws, #% of watershed area classified as hay land use
                perc_crop = PctCrop2016Ws, #% of watershed area classified as crop land use
                perc_wetland = PctWet2016Ws, #% of watershed area classified as herbaceous+woody wetland land cover
                perc_barren = PctBl2016Ws, #% of watershed area classified as barren land cover
                slope = SlopeWs, #Mean watershed slope, **I THINK**
                cti = WetIndexWs, #Mean Composite Topographic Index (CTI)
                dWL,
                Hylak_id,
                group) %>%
  mutate(WALA=ws_area/area,#drainage ratio, watershea area:lake area)
         n_dep=no3_dep+nh3_dep,#total N deposition
         perc_forest=perc_decid+perc_conifer+perc_mixedForest,#total forest cover
         perc_ag=perc_hay+perc_crop) %>% #total ag cover
  select(-c(perc_decid,perc_conifer,perc_mixedForest)) %>%
  na.omit(.) #Everything has to be complete data. 

  
#How many sites do we drop with na.omit()
# length(unique(blue_green_2018$Hylak_id))
#1318
# blue_green_2018 <- blue_green_2018 %>% na.omit(.)
# length(unique(blue_green_2018$Hylak_id))
#956




```


## Figures


### Site Map w/ Forel-Ule Color

```{r}


site_cols <- blue_green_2018 %>%
  mutate(dWL = round(dWL,0)) %>%
  inner_join(fui.lookup) %>%
  inner_join(fui.colors) %>%
  inner_join(lake_descriptor %>%
               dplyr::select(Hylak_id),.)




buffer_box <- st_bbox(site_cols) %>%
  st_as_sfc(.) %>%
  st_buffer(50000) %>%
  st_bbox()



ras <- get_elev_raster(site_cols, z = 5) %>%
  raster::crop(.,buffer_box)

ras[ras < 0] <- 0
slope <- terrain(ras, 'slope')
aspect <- terrain(ras, 'aspect')

hil <- hillShade(slope, aspect)

states <- USAboundaries::us_states()

#color for manually created legend
bg.fui = tibble(
  ymin = c(470,475,480,485,489,495,509,530,549,559,564,567,568,569,570,573,575,577,579,581,583),
  ymax = c(475,480,485,489,495,509,530,549,559,564,567,568,569,570,573,575,577,579,581,583,590),
  color = c(
  "#2158bc", "#316dc5", "#327cbb", "#4b80a0", "#568f96", "#6d9298", "#698c86", 
  "#759e72", "#7ba654", "#7dae38", "#94b660","#94b660", "#a5bc76", "#aab86d", 
  "#adb55f", "#a8a965", "#ae9f5c", "#b3a053", "#af8a44", "#a46905", "#9f4d04")
)

##Legend only
png(filename = 'figs/F-U_legend.png',
    width = 2.0, height = 11.8, units = 'in', res = 600)

ggplot() + 
  geom_rect(data = bg.fui, 
            aes(ymin = ymin, ymax = ymax, xmin = -5, xmax = 100, fill = color)) + 
  scale_fill_identity() + 
  theme_few() +
  scale_x_continuous(expand = c(0, 0))+
  scale_y_continuous(expand = c(0, 0), position="right")+
  theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.ticks.y=element_blank(),
        axis.text.y=element_text(size=28),
        axis.title.y=element_blank(),
        plot.title=element_text(size=28, hjust=0.5),
        plot.subtitle=element_text(size=24, hjust=0.5),
        plot.background = element_rect(fill="#FFFFFF"))
  # labs(y=" ",
  #      title="Forel-Ule color",
  #      subtitle="Dominant\nwavelength (nm)")
dev.off()

png(filename = 'figs/bg_better_map.png',
    width = 4, height = 6, units = 'in', res = 300)

tm_shape(hil) +
  tm_raster(palette = gray(0:10 / 10),
            style = "cont", legend.show = FALSE) + 
tm_shape(ras) + 
  tm_raster(alpha = 0.4,
            style = 'cont',
            title = 'Elevation (m)',
            palette = 'Greys') + 
tm_shape(states) + 
  tm_borders(lwd = 1,
             col = 'black') + 
tm_shape(site_cols) + 
  tm_bubbles(size = .2,
             col = 'color',
             border.col = 'black',
             border.lwd = 1,
             jitter = .3) +
tm_legend(legend.position = c(0,0),
            legend.bg.color = 'gray90',
            legend.frame = 'black') 


# base_map+inset_element(legend, 0.85, 0.75, 1, 1)
# 
# layout <- '
# A#
# AB
# A#
# '
# wrap_plots(A = base_map, B = legend, design = layout)+
#   plot_layout(widths = c(5, 0.5))

# base_map_grob<-tmap_grob(base_map)
# 
# plot_grid(base_map_grob,legend,
#           rel_widths = c(2,0.5),
#           rel_heights =c(1,1))
#   # scale=c(1,0.75))
# 
# ggpubr::ggarrange(base_map_grob, legend,
#                   heights = c(1, 0.25),
#                   widths = c(1, 1))

dev.off()


```


### Blue Green Category Only Map

```{r}



png(filename = 'figs/bg_map.png',
    width = 5, height = 8, units = 'in', res = 300)

tm_shape(hil) +
  tm_raster(palette = gray(0:10 / 10),
            style = "cont", legend.show = FALSE) + 
tm_shape(ras) + 
  tm_raster(alpha = 0.4,
            style = 'cont',
            title = 'Elevation (m)',
            palette = 'Greys') + 
tm_shape(states) + 
  tm_borders(lwd = 1,
             col = 'black') + 
  tm_shape(site_cols) + 
  tm_bubbles(size = .2,
             col = 'group',
             border.col = 'black',
             border.lwd = 1,
             jitter = .3,
             palette = c('deepskyblue2','darkolivegreen3')) + 
  tm_legend(legend.position = c(0,0),
            legend.bg.color = 'gray90',
            legend.frame = 'black') 

dev.off()



```

### Interactive BG map

```{r, eval = F}


# str(site_cols)
# mapviewOptions(fgb = F)
m1 <- mapview(site_cols, zcol = 'color', col.regions = site_cols$color,
              legend = F)

mapshot(m1, url = 'figs/lake_color_decade.html')

```


### Why blue, why green?


```{r}
#cart plot examples here:
#http://www.milbo.org/rpart-plot/prp.pdf
png(filename = 'figs/dwl_hist_2009-2020.png', width = 4, height = 4,
    units = 'in', res = 300)
spatial_hist<-ggplot() + 
  geom_rect(data = bg.fui, 
            aes(xmin = ymin, xmax = ymax, ymin = -5, ymax = 100, fill = color)) + 
  geom_vline(xintercept = 530, linetype = 3) +
  geom_histogram(data = blue_green_2018, aes(x=dWL, y = ..density..), fill = NA,
                 color = 'black', alpha = .3, bins = 40) + 
  geom_density(data = blue_green_2018, aes(x=dWL)) + 
  scale_x_continuous(expand = c(0, 0))+ #get rid of whitespace
  scale_fill_identity() + 
  theme_few() +
  coord_cartesian(ylim = c(0,.04))  +
  labs(x="Dominant wavelength (nm)",
       y="Density")
spatial_hist
dev.off()

blue_green_2018 %>%
  group_by(group) %>%
  summarize(n=length(unique(Hylak_id)))



set.seed(4444)

train_d <- blue_green_2018 %>%
  sample_frac(0.8) %>%
  mutate_if(is.numeric, round, digits=0) %>%
  rename("MAAT °C"=air_temp,
         "mean depth"=meandepth,
         WSA=ws_area)
#how many lakes in the training dataset?
# length(unique(train_d$Hylak_id))


test_d <- blue_green_2018 %>%
  dplyr::filter(!Hylak_id %in% train_d$Hylak_id) %>%
  dplyr::select(-Hylak_id,-dWL) %>%
  mutate_if(is.numeric, round, digits=0)%>%
  rename("MAAT °C"=air_temp,
         "mean depth"=meandepth,
         WSA=ws_area)

train_d <- train_d %>%
    dplyr::select(-Hylak_id,-dWL) 



## Not run, but code that helped make decision about complexity parameter
# prune_mod <-caret::train(
#   group ~., data = train_d, method = "rpart",
#   trControl = trainControl("boot", number = 100),
#   tuneLength = 100
#   )



cart_mod <- rpart(group ~ ., data = train_d,
                  method = 'class',
                  cp = 0.03) # CP is a tuning knob for tree complexity.



test_d$guess <- predict(cart_mod, test_d, 'class')
cm <- conf_mat(test_d, group,guess)
accuracy(test_d,group,guess)

# png(filename = 'figs/bg_tree.png',
# width = 7, height = 8, units = 'in', res = 300)
rpart.plot(cart_mod,
           # type = 4, #2=split labels below node labels; but I like the look of 4 with labels on both connecting lines and no "yesno"
           extra = 2,#2 = class rate; 106 = prob. of 2nd class + percent of observations
           under = TRUE, #I kind of like the look of this better
           clip.right.labs = FALSE,
           branch = 0.3,
           branch.type = 5, yesno=FALSE, #If you comment out type=4, I kind of like the look of this
           branch.col = "gray",
           # main="Factors that influence lake category",
           box.palette = list('#1f78b4','#33a02c'))
# dev.off()


## Create manually because the plot_confusion_matrix function is pissing me off
conf_mat <- confusion_matrix(targets = test_d$group,
                             predictions = test_d$guess)
table<-data.frame(conf_mat$`Confusion Matrix`)

plotTable <- table %>%
  group_by(Target) %>%
  mutate(prop = N/sum(N),
         prop = round(prop,2))

# fill alpha relative to sensitivity/specificity by proportional outcomes within reference groups (see dplyr code above as well as original confusion matrix for comparison)
# png(filename = 'figs/bg_confusion_matrix_gg.png',
#     width = 6, height = 5,
#     units = 'in', res = 300)
conf_matrix_plot<-ggplot(data = plotTable,
       mapping = aes(x = Target, y = Prediction, fill = Pos_Blue.clear)) +
  geom_tile(aes(fill=Pos_Blue.clear), color="black") +
  scale_x_discrete(expand = c(0, 0))+ #remove white space
  scale_y_discrete(expand = c(0, 0))+ #remove white space
  geom_text(aes(label = paste0("n=",N)), vjust = .5,  alpha = 1, size=4) +
  geom_text(aes(label = paste0("prop.=",prop)), vjust = 2.0,  alpha = 1, size=3) +
  scale_fill_manual(values = c(TP = "#1f78b4", TN = "#33a02c",
                               FN = "white" , FP ="white")) +
  theme_few() +
  # xlim(rev(levels(table$Target)))+
  theme(legend.position="none")
conf_matrix_plot
# dev.off()


#Old -- Matt's confusion matrix
# png(filename = 'figs/bg_confusion_matrix.png',
#     width = 6, height = 5,
#     units = 'in', res = 300)
# autoplot(cm, type = "heatmap") +
#   scale_fill_gradient(low="#D6EAF8",high = "#2E86C1")
# dev.off()

##Alternative confusion matrix using cvms library, ggplot2 friendly, but irritating to customize
# conf_mat <- confusion_matrix(targets = test_d$group,
#                              predictions = test_d$guess)
# conf_matrix_plot<-plot_confusion_matrix(conf_mat,
#                       add_counts = TRUE,
#                       target_col = "Target",
#                       prediction_col = "Prediction",
#                       add_row_percentages = FALSE,
#                       add_col_percentages = FALSE,
#                       counts_on_top = TRUE,
#                       tile_border_color = 'black',
#                       tile_border_linetype = "solid",
#                       darkness=0.7)+
#   ggplot2::scale_fill_distiller(palette = "Greys",direction=1)+
#   ggthemes::theme_few(base_size=18)+
#   labs(x="Truth",
#        y="Prediction")
# conf_matrix_plot





##GGPARTY? Another way
library(ggparty)
cart_mod_party<-as.party(cart_mod)
# plot(cart_mod_party)
tree_plot<-ggparty(cart_mod_party) +
  geom_edge(size=1, color="grey50") +
    # geom_node_label(aes(label = splitvar), ids = "inner") +
  geom_edge_label() +
  geom_node_splitvar() +
  geom_node_plot(gglist = list(geom_bar(aes(x = "", fill = group),
                                    position = position_fill()),#standardizes so each stack has constant height; plots proportions.
                               (scale_fill_manual(values=c('#1f78b4','#33a02c'))),
                                                               (theme_few()),
                               (theme(plot.margin = unit(c(0.5,0.2,0,0.2), "cm"),
                                axis.title.x=element_blank(),
                                axis.text.x=element_blank(),
                                axis.ticks.x=element_blank(),
                                legend.position="none")),
                               (scale_x_discrete(expand = c(0, 0))), #remove white space
                               # (scale_y_discrete(expand = c(0, 0))), #remove white space)
                               ylab("Proportion")),
                               shared_axis_labels = TRUE) +
  geom_node_label(aes(label = paste0("n=", nodesize)),
                  # fontface = "bold",
                  ids = "terminal",
                  size = 4, 
                  # nudge_y = 0.01,
                  nudge_x = 0.01)+
  theme(plot.margin = unit(c(0,0,0,0), "cm")) 
  # geom_text(aes(label = n), position = position_stack(vjust = 0.5), size = 3.2) 
tree_plot

## "Your decision tree may be cool, but what if I tell you you can make it hot?" LMAO.
# https://trang1618.github.io/treeheatr/articles/explore.html
# library(treeheatr)
# 
# # build tree using rpart:
# x <- partykit::as.party(cart_mod)
# 
# tree_plot<-heat_tree(x,
#           target_lab = 'group',
#           target_cols = c('#1f78b4','#33a02c'),
#           feats = NA, 
#           # feats = c('slope', 'maxdepth', 'WALA', 'air_temp'), #select only features on the tree
#           # show = 'tree-only',
#           # cont_legend = TRUE, cate_legend = TRUE,
#           panel_space = 0.05, target_space = 0.2, tree_space_bottom = 0.1, heat_rel_height = 0.1,
#           edge_vars = list(size = 1, color = 'grey'))
# tree_plot


#Combine
library(patchwork)
# (tree_plot + conf_matrix_plot + spatial_hist )+
#   plot_layout(ncol = 1) 
# 
# spatial_hist / (tree_plot + conf_matrix_plot + plot_layout(widths = c(1,0.5))) + 
#   plot_layout(heights = c(0.5,1.5))

##Arrangement 1
png(filename = 'figs/spatial_plots.png',
width = 6, height = 7, units = 'in', res = 600)
C<-(spatial_hist+conf_matrix_plot)
(C/tree_plot)+ plot_layout(heights = c(0.3,1))+  plot_annotation(tag_levels = 'A')
#For top right alginment: inset_element(conf_matrix_plot, left = 0.67, bottom = 0.67, right = 1, top = 1, align_to = 'full')) 
dev.off()

##Arrangement 2
B <- spatial_hist / conf_matrix_plot +   plot_layout(heights = c(2,1))
tree_plot + B  +   plot_layout(widths = c(2,1)) +  plot_annotation(tag_levels = 'A')

##Arrangement 3
(spatial_hist / tree_plot + inset_element(conf_matrix_plot, left = 0.67, bottom = 0.67, right = 1, top = 1, align_to = 'full')) +
   plot_layout(heights = c(0.5,1.5))+
   plot_annotation(tag_levels = list(c('A', 'B'), '1'))


```


Plot some of these relationship for funsies
```{r}
# head(blue_green_2018)

#Slope histogram
blue_green_2018 %>%
  ggplot( aes(x=slope, fill=group)) +
    geom_histogram( color="#e9ecef", alpha=0.9, position = 'identity') +
    scale_fill_manual(values=c('#1f78b4','#33a02c'))

#elevation histogram
blue_green_2018 %>%
  ggplot( aes(x=elev, fill=group)) +
    geom_histogram( color="#e9ecef", alpha=0.9, position = 'identity') +
    scale_fill_manual(values=c('#1f78b4','#33a02c'))
blue_green_2018 %>%
  ggplot( aes(y=elev, x=group, fill=group)) +
    geom_boxplot(alpha=0.9) +
    scale_fill_manual(values=c('#1f78b4','#33a02c'))
#Generally higher elevation lakes are blue, no surprise there. 
wilcox.test(elev~group, data=blue_green_2018)



# no3 and nh4 deposition come up in the CART plot. Looks at historgrams
blue_green_2018 %>%
  ggplot( aes(x=nh3_dep, fill=group)) +
    geom_histogram( color="#e9ecef", alpha=0.9, position = 'identity') +
    scale_fill_manual(values=c('#1f78b4','#33a02c'))

blue_green_2018 %>%
  ggplot( aes(x=no3_dep, fill=group)) +
    geom_histogram( color="#e9ecef", alpha=0.9, position = 'identity') +
    scale_fill_manual(values=c('#1f78b4','#33a02c'))


#Are deposition rates higher at high elevations?
blue_green_2018 %>%
  ggplot(aes(x=nh3_dep,y=elev, fill=group))+
  geom_point(shape=21,size=3, alpha=0.9)+
  scale_fill_manual(values=c('#1f78b4','#33a02c'))

```

## Table 1. 
```{r}
head(blue_green_2018)
skim(blue_green_2018)

covariates<-blue_green_2018 %>%
  skim() %>%
  filter(skim_type=="numeric")  %>%
  select(skim_variable, numeric.mean, numeric.sd) %>%
  mutate(
    numeric.mean=round(numeric.mean,1),
    numeric.sd=round(numeric.sd,1),
    meansd = paste0(numeric.mean, " (",numeric.sd,")")) %>%
  select(-numeric.mean,-numeric.sd) %>%
  filter(!skim_variable %in% list("Hylak_id","dWL","LSA","n_dep")) %>%
    mutate(Description=NA) %>%
    mutate(Description=
           ifelse(skim_variable=="precip", "mean monthly precipitation (mm)", 
           ifelse(skim_variable=="air_temp","mean annual air temperature (°C)", 
           ifelse(skim_variable=="area", "lake surface area (km2)",
           ifelse(skim_variable=="elev", "lake elevation (m)",
           ifelse(skim_variable=="pop_sum", "total human population",
           ifelse(skim_variable=="maxdepth", "max lake depth (m)",
           ifelse(skim_variable=="meandepth", "mean lake depth (m)",
           ifelse(skim_variable=="ws_area", "watershed area (km2)",
           ifelse(skim_variable=="no3_dep", "total no3 deposition (2018)",
           ifelse(skim_variable=="nh3_dep", "total nh3 deposition (2018)",
           ifelse(skim_variable=="carb", "some geological descriptor",
           ifelse(skim_variable=="sil", "some geological descriptor",
           ifelse(skim_variable=="perc_ice", "% of watershed area classified as ice/snow land cover",
           ifelse(skim_variable=="perc_urban", "% of catchment area classified as developed, low+med+high-intensity land use",
           ifelse(skim_variable=="perc_decid", "% of catchment area classified as deciduous forest land cover",
           ifelse(skim_variable=="perc_conifer", "% of catchment area classified as evergreen forest land cover ",
           ifelse(skim_variable=="perc_mixedForest", "% of catchment area classified as mixed deciduous/evergreen forest land cover",
           ifelse(skim_variable=="perc_shrub", "% of catchment area classified as shrub/scrub land cover ",
           ifelse(skim_variable=="perc_grass", "% of watershed area classified as grassland/herbaceous land cover ",
           ifelse(skim_variable=="perc_wetland", "% of watershed area classified as herbaceous+woody wetland land cover",
           ifelse(skim_variable=="perc_hay", "% of watershed area classified as hay land use",
           ifelse(skim_variable=="perc_crop", "% of watershed area classified as crop land use",
           ifelse(skim_variable=="perc_barren", "% of watershed area classified as barren land cover",
           ifelse(skim_variable=="slope", "*Check on this* Mean watershed slope angle",
           ifelse(skim_variable=="WALA", "Watershed area:lake area",
           ifelse(skim_variable=="cti", "*Check on this* Composite topographic index"," "))))))))))))))))))))))))))) %>%
  mutate(skim_variable=recode(skim_variable,
                              precip="precip.",
                              air_temp="air temp.",
                              area="LA (km2)",
                              elev="elev. (m)",
                              meandepth="Mean depth (m)",
                              maxdepth="Max depth (m)", 
                              pop_sum="Population",  
                              ws_area="WSA (km2)",
                              WALA="WA:LA",
                              no3_dep="NO3 dep.", 
                              nh3_dep="NH3 dep.",
                              carb="carb.",
                              sil="sil.",
                              perc_ice="% ice,",
                              perc_urban="% urban",
                              perc_decid="% decid.",
                              perc_conifer="% conifer",
                              perc_mixedForest="% mixed forest",  
                              perc_shrub="% shrub",
                              perc_grass="% grassland",     
                              perc_wetland="% wetland",
                              perc_hay="% hay",
                              perc_crop="% cropland",      
                              perc_barren="% barren",
                              cti="CTI"))

###EXPORT TABLE
summary_table_export <-
  covariates %>%
  rename("Variable"=skim_variable,
         "Mean (sd)"=meansd) %>%
  hux(add_colnames=TRUE) %>%
  # add_footnote() %>%
  set_bold(row = 1, col = everywhere, value = TRUE) %>% 
  set_all_borders(TRUE) %>%
  set_all_padding(0) %>%
  set_outer_padding(0) %>%
  theme_article()


quick_docx(summary_table_export, file = 'figs/Table1.docx')
```

```{r, eval=F}
#Export a few pieces we need for analysis 3.
save(blue_green_2018,site_cols,hil,ras,states, file = 'data/spatial_data_analysis2.RData')
```
